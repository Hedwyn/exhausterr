{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"exhausterr: Exhautive Error Handling / Railway Programming in Python","text":"<p>A library implementing error as values in Python with exhaustiveness verifiability, type safety and pattern matching. Brings flavors of Zig and Rust error handling to Python towards higher reliability in critical Python programs. Integrate errors as part of you control flow and leverage the full potential of type checkers to assert code behavior. This utility should help you applying the base principles of railway programming while squeezing their full potential out of type checkers.</p>"},{"location":"#installation","title":"Installation","text":"<p>Requires Python&gt;=3.11. Based on hatchling as the build backend.</p> <pre><code>pip install exhausterr\n</code></pre> <p>Or if using hatch frontend: <pre><code>hatch shell\n</code></pre></p>"},{"location":"differences_returns/","title":"Differences compared to 'results' library","text":"<p>If are familiar with the great returns library for Python you might have noticed that the functionality in this package is very similar. This section explains the core differences.</p>"},{"location":"differences_returns/#size-and-goals","title":"Size and goals","text":"<p><code>exhausterr</code> is focused on a very narrow domain which is error as values and exhaustive error handling. <code>returns</code> on the other hand, is an implementation of common monad patterns that you would find in functional programming languages like Haskell (e.g., IO, Env, Maybe, etc.). As a consequence its scope is significantly wider than this package. If you are willing to integrate common monad patterns in your Python code you should definitely use <code>returns</code>, which does it very well and is most likely the most solid Python implementation available currently. The ambition of <code>exhausterr</code> is not to implement monadic patterns, and there is no plan to integrate monad-like objects other than Results for now. Now that this is cleared up, the next sections cover the differences when it comes to the functionalities that are actually shared by the two libraries.</p>"},{"location":"differences_returns/#design-philosophy","title":"Design philosophy","text":"<p>The main difference between the two packages is, arguably, the design philosophy. The goal of <code>exhausterr</code> is to squeeze the full potential out of type checkers, without requiring any custom plugins. This means that whenever possible it will favor static analysis over runtime checks. It is basically aiming to get similar semantic verification from the type checker as Rust or Zig code would get from their respective compilers - when it comes to error handling, obviously. As a consequence, there is a very deliberate choice to not add runtime logic for something that can be formally checked at type checking time. <code>Results</code> on in <code>returns</code> are one of many monad(-like) objects that supports the general monad protocol (think bind / compose). If you do not need about these monad-flavors and is simply want solid error-as-values it gives sightly less assets at type checking time compared to <code>exhausterr</code>:</p> <ul> <li>Exhaustiveness: when using the returns' Result, the type checker won't be able to infer that checking both the Ok and Error case (called <code>Success</code> and <code>Failure</code>) is exhaustive. For example this fails with myp:</li> </ul> <pre><code>from returns.result import Result\n\ndef show_result(Result[float, float]) -&gt; None:\n    match only_positive(i):\n        case Success(x):\n            print(\"Success ! \", x)\n        case Failure(y):    \n            print(\"Failure ! \", y)\n        case _ as never:\n            assert_never(never)\n</code></pre> <ul> <li>Type narrowing with if: returns' Result do not support <code>__bool__</code> at all, where as an <code>exhausterr</code> will allow you to call <code>if result</code> for a success-condition and the type will be narrowed to <code>Ok</code> within the scope (and vice-versa). This by extension also prevents stream-lined boolean logic (e.g. <code>all</code>, <code>any</code> on a bunch of results).</li> </ul> <p>The other big differnece is the definition of errors. Results from returns accept arbitrary types - but the package is mainly designed to work around exceptions as the error type. <code>exhausterr</code> on the other hand uses deliberately a base class for errors that is not an exception, and does not allow non-errors as the error return of Results.</p>"},{"location":"differences_returns/#implementation-of-errors","title":"Implementation of errors","text":"<p>On top of the <code>Result</code> implementation <code>exhausterr</code> provides a custom error tyope, which is intended to be clearly differentiated from exceptions. You can still come back and forth between the two worlds (<code>Error</code> has an <code>exception_cls</code> attribute pointing to the exception type to use and you can <code>throw</code> them); however, the error-as-values objects are clearly separted from the exception system. Part of the motivation is to clear any possible confusion on how these objects are supposed to be used; the other part is to avoid creating complex and bloated objects. Exception is a built-in object of Python with special handling, and although it can pretty much be used like any normal class, there something a bit dangerous about adding complex functionalities on top of it, which ends up being kind of an anti-pattern. It might also not evolve well with the current evolution of Python, as the last versions have introduced new advanced exception-related features such as exception groups. As these continue to grow one should not exclude that a custom class on top of exceptions might become conflictual eventually. <code>Error</code> in <code>exhausterr</code> are designed for arguments carrying and pattern matching. They support primitives to format them into exceptions and throw them, but there are still isolated in their own space.</p>"},{"location":"differences_returns/#summary","title":"Summary","text":"<p>If you want to get a full package for functional programming experience, and/or are specifically looking for monad patterns, you should use <code>returns</code>. If you mainly care about error-as-values, exhaustiveness, and railway programming, <code>exhausterr</code> is worth considering, as a more focused and minimal library. It should provide more semantic assets type checking-wise, and has a more formal (and arguably more restrictive) error model.</p>"},{"location":"manifesto/","title":"Manifesto","text":""},{"location":"manifesto/#what-does-error-as-values-mean","title":"What does \"error as values\" mean ?","text":"<p>You might not know it yet, but when programming sometimes shit goes wrong. When writing a function that can fail, one needs a way to inform the function caller that something went wrong. \"Error as values\" simply means that the return value of the function itself will tell whether the call was successful or failed, and was the historical and for a long time only way to deal with errors. In C typically, function that can error typically return an integer encoding either success or an error type, while the actual payload procuced by the function woud typically by passed by giving a pointer to memory location where it should be written. Exceptions are the main alternative (or complement...as we will discuss later) to error-as-values, and have been popularized by languages like Java. Languages with exception support provide them as a way to interrupt a function early on and navigate backward in the call stack -until finding a caller that knows how to deal with it. From the programmer's perspective, they are usually kept out of the type system, and in a way isolated from the main control flow, which then is kept centered on the happy path.</p>"},{"location":"manifesto/#why-using-exceptions","title":"Why using exceptions ?","text":"<p>Philosophy of exceptions is to simplify the main control flow ('happy path') by isolating (some would dare to say hiding) errors from it. The idea behind is that you only care about errors if you know how to deal wih them, otherwise it's fine to not even know about them.  To achieve that, one key property of exceptions is that it gets implicitly forwarded through the call stack until it hits something that can deal with it (typically through some <code>try...catch</code> syntax, where <code>catch</code> allows you to specify what type of error(s) you are able to deal with).  Thus, some of the main difference between error-as-values and exceptions are the following:</p> <ul> <li>Exceptions will not allow you to delay the error handling. Either you catch and deal with the problem, or your function will be interrupted and the exceptyion will go one step up in the call stack. With error as values, you can go farther in the function body and deal with the error later.</li> <li>Exceptions travel implicitly through the call stack, while error-as-values have to be explictly forwarded.</li> <li>Exceptions are usually not integrated in the type system. (Java checked exceptions is one exception - sorry for the pun). Modern languages using aerror-as-values are typically able to integrate errors in the type system, allowing the errors that a given function could produce to be exposed clearly in the type system. </li> </ul>"},{"location":"manifesto/#the-issue-with-exceptions","title":"The issue with exceptions","text":"<p>Exceptions also have some major drawbacks and are definitely not loved by everyone, leading to some modern languages do not implement them on purpose. In particular:</p> <ul> <li>In their primary form, they basically break all formal verifiability of programs in typed languages, due to the fact they are out of the type system. Checked exceptions are an attempt to solve that (notably in Java), but they end upm often being the worst of both worlds instead of the best. </li> <li>It's extremly difficult to deal with all possible failure modes in an exhaustive manner, since the exceptions are inherently hiding the error flow compared to a naive \"return code as error\" C-like approach. The fact that exceptions travel implicitly through the calls makes them very difficult if not impossible to integrate them in a verifiable system..</li> <li>They need special mecanisms to handle them in asynchronous contexts. Remember, exceptions by definition do not allow delaying the error handling - while asynchronous code is all about delaying stuff. This introduces further complexity in code coloring, and prevents from dealing with the \"good\" and \"bad\" path in a symmetric way in asynchronous contexts. Also, if something like <code>asyncio</code> already bundles this type of mecanisms, for concurrent code based on thread this boilerpalte has to be written manually.</li> </ul> <p>In real-time, safety critical systems where reliability is extremly critical, exceptions are often counter-productive. Asserting code behaviour is crucial in these contexts, and exceptions are pretty bad for that, being too opaque. The whole \"you don't need to know about errors if you can't deal with it\" idea does not scale very well in safety critical systems. The whole concept of being potentially hit by an error coming from a depth-5 callee in the calls stack is also far from being an asset. Errors travelling implictly by more than one call in the stack in a completely opaque way is particularly bad in that context.</p> <p>Exceptions simplify the business logic as long as the program won't kill anyone if there's a bug - in that latter case, one would usually better pay the price of dealing with errors as part of the control flow- because it's much less bug-prone. There are reasons for which Rust is considered as one of the most powerful programming language for high-reliability application, and the error handling is one of them.</p>"},{"location":"manifesto/#so-should-one-refrain-from-using-exceptions","title":"So, should one refrain from using exceptions ?","text":"<p>In a language like Python, definitely not. The idiomatic way to deal with errors in Python is to use exceptions - and going against what's idomatic is rarely a good idea. In the end, whether to use exceptions or error as values is basically a tradeoff between simplified control flow and verifiability. In the context of enteprise software for which Java was and still is extremly popular, errors are typically not life threatening and one might see why exceptions got so popular. In programming contexts where the most of the worload is put toward maximizing robustness and relibaility, they are sort of a footgun.</p>"},{"location":"manifesto/#using-both-exceptions-as-a-soft-panic","title":"Using both: exceptions as a soft panic","text":"<p>The heart of the problem is that errors and exceptions are not supposed to be the same. Although some languages made idomatic to use exception for any type of error (Python included !), exceptions are supposed to be for... exceptional errors.  Although what should be considered exceptional is highly subjective, application-dependant and might evolve other time, there are for sure tons of errors out there that are definitely not exceptional. A user making a typo in a form for example is hardly something that should be deemed exceptional. Having this case encoded in the type system makes much easier to verify that the software handles every possible situation exhaustively.  On the other end, it's impossible to deal with every single possible error out there. Typically, a lot of programs would not consider the case of a failure when allocating a memory, even though any memory allocation is susceptible to failure (if memory is full, for example). First, because checking every single memory allocation quickly gets annoying, and also simply if your memory is full there are probably already so many things broken that your program not working is the least of the user's worries.  Think about it: running pretty much anything in Python can technically raise <code>MemoryError</code> - yet there's very little you could do about it if it happens. Cluttering the control flow with memory errors would be non sense. This sorts of fall into the <code>exceptional</code> category, a type of situation in which you would typically panic in a low-level lanugage, i.e. crash early and try to provide some context on what happens. From that regard, one can look at exception as a soft panic mecanism. Unlike a true panic, you give a chance to the program to recover it it catches it somewhere, while simplifying your control flow from the type system perspective.</p>"},{"location":"tutorials/","title":"Usage","text":""},{"location":"tutorials/#a-simple-example","title":"A simple example","text":"<p>Have a look at the <code>examples</code> folder.  If we look at <code>examples/results.py</code>: <pre><code>\"\"\"\nA naive example on how to use Result and Error\n\"\"\"\n\nimport random\nfrom enum import Enum, auto\nfrom typing import assert_never\nfrom exhausterr import Error\nfrom exhausterr import Result, Ok, Err\n\n\nclass CoinTossResult(Enum):\n    HEADS = auto()\n    TAILS = auto()\n\n\nclass LandedOnEdge(Error):\n    pass\n\n\nclass DownTheGutter(Error):\n    pass\n\n\ndef toss_a_coin() -&gt; Result[CoinTossResult, LandedOnEdge | DownTheGutter]:\n    \"\"\"\n    Plays heads or tails... with a few twists !\n    \"\"\"\n    rng = random.random()\n    if rng &lt; 0.1:\n        return Err(DownTheGutter())\n\n    if rng &lt; 0.2:\n        # jeez, we landed on an edge\n        return Err(LandedOnEdge())\n\n    result = CoinTossResult.HEADS if rng &lt; 0.6 else CoinTossResult.TAILS\n    return Ok(result)\n\n\ndef play() -&gt; None:\n    \"\"\"\n    Tosses a coin and informs the player about the result\n    \"\"\"\n    res = toss_a_coin()\n    match res:\n        case Ok(coin):\n            print(\n                f\"Got {coin.name.lower()}, you {'won' if coin == CoinTossResult.HEADS else 'lost'} !\"\n            )\n\n        case Err(err):\n            # Something went wrong.. but what\n            match err:\n                case LandedOnEdge():\n                    print(\"You landed on an edge ! Let's flip the coin again.\")\n\n                case DownTheGutter():\n                    print(\"Ops, you lost a coin, let's get another one !\")\n\n                case _ as unreachable:\n                    assert_never(unreachable)\n\n        case _ as unreachable:\n            assert_never(unreachable)\n\n\nfor _ in range(100):\n    play()\n</code></pre> The first thing to pay attention is the return type of <code>toss_a_coin</code>, which is <code>Result[CoinTossResult, LandedOnEdge | DownTheGutter]</code>. If you are familiar with Rust syntax, this should be fairly transparent already. This reads as this function provides a <code>CoinTossResult</code> on success, and an error on failure which can be either <code>LandedOnEdge</code> or <code>DownTheGutter</code>. The <code>Result</code> annotation is simply the union of <code>Ok</code> and <code>Err</code> under the hood, which you can see in action in the function body itself: <pre><code>def toss_a_coin() -&gt; Result[CoinTossResult, LandedOnEdge | DownTheGutter]:\n    \"\"\"\n    Plays heads or tails... with a few twists !\n    \"\"\"\n    rng = random.random()\n    if rng &lt; 0.1:\n        return Err(DownTheGutter())\n\n    if rng &lt; 0.2:\n        # jeez, we landed on an edge\n        return Err(LandedOnEdge())\n\n    result = CoinTossResult.HEADS if rng &lt; 0.6 else CoinTossResult.TAILS\n    return Ok(result)\n</code></pre> In a nutshell: if your function succeeds, return <code>Ok(your_return_value)</code>, otherwise return <code>Err(the_error_that_occured)</code>.</p> <p>Then, callers can examine the result thourgh pattern matching: <pre><code>def play() -&gt; None:\n    \"\"\"\n    Tosses a coin and informs the player about the result\n    \"\"\"\n    res = toss_a_coin()\n    match res:\n        case Ok(coin):\n            print(\n                f\"Got {coin.name.lower()}, you {'won' if coin == CoinTossResult.HEADS else 'lost'} !\"\n            )\n\n        case Err(err):\n            # Something went wrong.. but what\n            match err:\n                case LandedOnEdge():\n                    print(\"You landed on an edge ! Let's flip the coin again.\")\n\n                case DownTheGutter():\n                    print(\"Ops, you lost a coin, let's get another one !\")\n\n                case _ as unreachable:\n                    assert_never(unreachable)\n\n        case _ as unreachable:\n            assert_never(unreachable)\n</code></pre> At this point, you might want to run mypy on this example (<code>mypy examples/results.py --strict</code>). It should not detect any errors: <pre><code>Success: no issues found in 1 source file\n</code></pre> You might have noticed the <code>case _ as unreachable: ...</code>; this is the idomatic way in Python to check that a path is not reachable, or more precisely here, that a match statement is actually exhaustive.  Try now commenting out the <code>case DownTheGutter</code> arm, or the entire <code>case Err(err)</code> arm entirely. You should now get errors when type checking: <pre><code>results.py:62: error: Argument 1 to \"assert_never\" has incompatible type \"DownTheGutter\"; expected \"NoReturn\"  [arg-type]\nFound 1 error in 1 file (checked 1 source file)\n</code></pre> <code>mypy</code> now spots that we are now covering one possible error path - <code>DownTheGutter</code>, in that case.  This is obviously a silly example, but this should demonstrate the spirit of exhaustive error handling. Typical error flow with exceptions do not allow this type of static verification on code coverage and exhaustiveness. Note that you may also use <code>if / else</code> logic and still benefit from type narrowing. Running <code>if result: ...</code> gives you always True for <code>Ok</code> results and always False for <code>Err</code>. See the following example (<code>examples/results_with_if.py</code>):</p> <pre><code>from exhausterr import Result, Error\nfrom typing import reveal_type\n\ndef check_result(result: Result[int, Error]) -&gt; None:\n    \"\"\"\n    Demonstrates that type narrowing is properly performed\n    when using `if` statements instead of `match`.\n    Running 'if result: ...' will narrow the result to Ok(...)\n    wihin `if` scope and to Err(...) in the `else` scope.\n    \"\"\"\n    if result:\n        # revealed type is Ok[int]\n        reveal_type(result)\n    else:\n        # revealed type is Err[Error]\n        reveal_type(result)\n</code></pre>"},{"location":"tutorials/#standard-patterns","title":"Standard patterns","text":"<p>There are about three idiomatic patterns you can use with <code>Result</code>: <code>match</code> statement, <code>if</code> / <code>else</code> and <code>unwrap()</code>. We already covered the pattern matching style above, which as a reminder is as follows: <pre><code>match my_result:\n    case Ok(some_value):\n        # ... do something with the value\n\n    case Err(an_error):\n        # do something with the error\n</code></pre></p> <p>Sometimes <code>match</code> statements might feel like an overkill. If you do not need the pattern matching (that is, if you only want to know if it's an error or a success and you do not need to match the inner value), <code>if</code> / <code>else</code> is a perfectly acceptable and supports construct (snippet below is taken from <code>examples/results_with_if.py</code>):</p> <p><pre><code>def check_result(result: Result[int, Error]) -&gt; None:\n    if result:\n        # revealed type is Ok[int]\n        reveal_type(result)\n    else:\n        # revealed type is Err[Error]\n        reveal_type(result)\n</code></pre> Type narrowing will be performed correctly by your type checker: within the <code>if</code> scope, the type of your <code>Result</code> will be narrowed to <code>Ok</code>, while in the scope of <code>else</code> it will be narrowed to <code>Err</code>. Thus, you gets the same verifiability benefits as the <code>match</code> statement - without the actual pattern matching. This is quite useful for Results that carry a <code>None</code> value, or for logic that only considers one of the two cases. The last construct is <code>unwrap()</code>, which in the Rust world means \"give the the result or panic\". Calling <code>unwrap()</code> will give you the inner value for an <code>Ok</code> result, and will <code>throw</code> (raise) the error for <code>Err</code> (Note: all errors have a class-defined exception class to use when they're raised). Unlike Rust that panics in case of errors, you program can still recover by catching the exception, but the error will now be hidden from your control flow type-wise. Thus, that's a pattern that you should use with caution; it is however quite useful in the following cases:</p> <ul> <li>script-like code, that does not require to be polished</li> <li>Internal control flows for which you know that the error case has been checked previously due to the execution order.</li> <li>In places where you know nothing can handle the error locally anyway and you would rather use standard exception-based propagation (i.e. to convert errors \"back\" to exception-style).</li> </ul>"},{"location":"tutorials/#derived-patterns","title":"Derived patterns","text":"<p>A useful pattern for defaulting is <code>my_variable = some_result or default_value</code> - this reads as \"give me the result value if <code>Ok</code>  or use the if <code>Err</code>\". This is directly derived from the implementation of <code>__bool__</code> in Results, which was also used in the <code>if</code> / <code>else</code> examples above. <code>Ok</code> will always evaluate to <code>True</code> in boolean operations, and <code>Err</code> to <code>False</code>.</p>"}]}